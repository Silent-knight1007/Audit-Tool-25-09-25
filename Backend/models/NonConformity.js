import mongoose from 'mongoose';

const nonConformitySchema = new mongoose.Schema({
  auditId: { type: String, required: true },
  ncId: { type: String, required: true, unique: true }, // Unique NonConformity ID (autogenerated)

  ncDescription: { type: String, required: true },
  ncClauseNo: { type: String, required: true },
  ncType: { type: String, required: true },
  reportingDate: { type: Date, required: true },
  dueDate: { type: Date, required: true },
  department: { type: String, required: true },

  // Embedded responsible person details (name & email required)
  responsibleperson: {
    name: { type: String, required: true },
    email: { type: String, required: true }
  },

  nclocation: { type: String, required: true },

  ncCorrectiveAction: { type: String },
  ncPreventiveAction: { type: String },
  ncRootCause: { type: String, required: true },
  ncstatus: { type: String, required: true },

  attachments: [
    {
      filename: { type: String },
      originalname: { type: String },
      mimetype: { type: String },
      size: { type: Number },
      path: { type: String }
    }
  ]
}, { timestamps: true }); // Adds createdAt and updatedAt timestamps

// Pre-validate hook to auto-generate ncId per auditId
nonConformitySchema.pre('validate', async function (next) {
  if (!this.isNew) return next();

  try {
    if (!this.auditId) {
      return next(new Error('auditId is required to generate ncId'));
    }
    const count = await mongoose.model('NonConformity').countDocuments({ auditId: this.auditId });
    const serial = String(count + 1).padStart(3, '0');
    this.ncId = `${this.auditId}NC${serial}`;
    next();
  } catch (err) {
    next(err);
  }
});

// Remove model if already registered to support hot-reloading/dev
delete mongoose.connection.models['NonConformity'];

const NonConformity = mongoose.model('NonConformity', nonConformitySchema);

export default NonConformity;
